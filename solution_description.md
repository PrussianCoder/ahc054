# AHC054 Solution Description - main.cpp

## 概要

この解法はAHC054「森の花探し」問題のためのC++実装です。冒険者が花を探すまでの移動回数を最大化するために、戦略的に木を配置する多段階最適化アルゴリズムを採用しています。

## 問題設定

- **目標**: N×Nの森で冒険者の移動回数を最大化
- **制約**: 冒険者は花（ゴール）に必ず到達できる必要がある
- **戦略**: 木を配置して冒険者を迷わせつつ、最終的な到達は保証

### 初期盤面例（20×20）
```
........T.ST........
..............T.....
T...................
........T...........
...T................
.....T..............
..........T.........
....................
......T.T.........T.
....T..........T..T.
.T..T........T.....T
........T...........
....................
.....TT.............
.................T..
....................
........X.T.........
............T.....T.
....................
...........T.TTT....
```

**記号説明**:
- `.`: 空きセル (EMPTY)
- `T`: 初期配置の木 (TREE)
- `S`: スタート地点 (START)
- `X`: ゴール地点（花の位置） (GOAL)
- `*`: パス (PATH)
- `#`: 新規配置の木 (NEW_TREE)

## 全体アーキテクチャ

### 3段階最適化パイプライン

```cpp
// Phase 1: 候補生成 (1.0秒)
vector<Board> board_candidates;

// Phase 2: ペナルティ計算とソート
BoardChecker checker;
vector<tuple<int, int, int>> penalty_path_indices; // (penalty, -path_count, index)

// Phase 3: 最適候補の評価 (残り0.8秒)
BoardSimulator evaluators[NUM_EVALUATIONS];
```

#### Phase 1: 候補ボード生成
- **時間制限**: 1.0秒
- **処理**: Step0〜Step6の全段階を実行してボード候補を大量生成
- **多様性確保**: ランダム変換（上下反転、左右反転）により解空間を拡大

#### Phase 2: ペナルティベースソート
- **評価指標**: BoardCheckerによるペナルティ計算
- **ソート条件**:
  1. ペナルティ昇順（小さいほど優先）
  2. PATH数降順（多いほど優先、同一ペナルティ内）
- **効果**: 品質の高いボードを優先的に評価

#### Phase 3: シミュレーション評価
- **対象**: ペナルティが最小値のボードのみ
- **評価**: BoardSimulatorによる実際の移動回数計算
- **最適化**: 最小ペナルティ内で最高スコアのボードを選択

## 核心アルゴリズム

### Step0Constructor: 初期探索パス
スタート地点から近距離の探索パスを構築します。

```cpp
// スタート付近の短距離探索パスを構築
pair<int,int> _find_random_target(const Board& board, int start_i, int start_j);
vector<pair<int,int>> _find_path_bfs(const Board& board, int si, int sj, int ti, int tj);
```

### Step1Constructor: ゴール周辺パターン配置
ゴール（花X）の周辺に戦略的な木配置パターンを適用します。

#### 8種類の配置パターン例

**パターン1**: 右側通路
```
.#.
**#
#X#
.#.
```

**パターン2**: 左側通路
```
.#.
#**
#X#
.#.
```

**パターン5**: 水平通路
```
.*#.
#*X#
.##.
```

#### Step1適用後の盤面
パターン1を採用した場合の変化：
```
........T.ST........
..............T.....
T...................
........T...........
...T................
.....T..............
..........T.........
....................
......T.T.........T.
....T..........T..T.
.T..T........T.....T
........T...........
....................
.....TT.............
........#........T..    ← 新規配置木
.........#..........    ← 新規配置木
.......#X#T.........    ← ゴール周辺パターン
........#...T.....T.    ← 新規配置木
....................
...........T.TTT....
```

### Step2Constructor: 動的プログラミングによる縦パス構築
左右端に効率的な縦パスを動的プログラミングで構築します。

#### 実装アルゴリズム
```cpp
// dp[i][l][r] = i行目のl〜r範囲をパスとする最小コスト
vector<vector<vector<double>>> dp;

// 初期化: l<edge_sizeの場合にペナルティ加算
int pen = (l < edge_size ? penalty : 0);
dp[0][l][r] = r + pen;

// 遷移パターン1: (l,r) → (r,r2) 右拡張
// 遷移パターン2: (l,r) → (l2,r) 左拡張
```

#### Step2適用後の盤面
左右端に縦パスが構築された状態：
```
..*.....T.ST.....*..
..*...........T..*..
T.*..............*..
..*.....T........*..
..*T.............*..
..*..T...........*..
..*.......T......*..
..*..............*..
..*...T.T........*T.
..*.T..........T.*T.
.T*.T........T...*.T
..*.....T........*..
..*..............*..
..*..TT.........**..
..*.....#.......*T..
..*......#......**..
..*....#X#T......*..
..*.....#...T....*T.
..*..............*..
..*........T.TTT.*..
```

### Step3Constructor: 蛇行パス生成
左端から開始して複雑な蛇行パスを動的に構築します。

```cpp
// 左端から開始して右端まで到達するパスを動的に構築
pair<Board,bool> construct(Board board, int path_type, int start_i = 0);
```

#### 蛇行パスの特徴
- 既存の縦パス間を接続
- 動的範囲設定による効率的探索
- 分岐可能性を考慮した経路選択

### Step5Constructor: 分岐生成システム
既存パスから戦略的に分岐を生成し、冒険者を迷わせます。

#### 分岐生成の例

**変更前**: 単純な縦パス
```
..*.
..*.
..*.
..*.
..*.
```

**変更後**: 2セル分岐追加
```
..*.
..*.
..*.
##*.
***.
```

#### 分岐生成アルゴリズム
1. パス（C）に隣接する空きセル（A）とその先（B）をチェック
2. A、Bが他のパスと隣接していないことを確認
3. 条件を満たす場合、A、Bをパスに変更
4. A、Bの周囲の空きセルを木に変更

#### 全体適用後の複雑な盤面
```cpp
bool _try_create_branch(Board& board, int pi, int pj, bool use_hidden_tree);
bool _try_create_three_branch(Board& board, int pi, int pj, bool use_hidden_tree);
```

```
##***...T.*T****.***
***.*.***.***.T*.*##
T#*.*.*.**.*.***.***
***.*.*.T*.*.*...*##
##*T*.*..*.*.*.*****
***.*T*..*.*.*...*##
##*.*.**.*T*.*.*****
***.*..*.*.*.*...*##
##*.**T*T*.*.*.***T.
***.T*.*.*.*.**T.*T.
#T*.T*.*.*.*.T**.*.T
***.**.*T*.***.*.***
##*.*..*.*...*.*.*##
***.*TT*.***.*.*****
##*.*.**#..*.*..*T##
***.*.***#.*.*..****
##*.*.*#X#T*.*...*##
***.*.*.#***T*...*T#
##*.*.*####***.*****
***.*****#.T.TTT.*##
```

### Step6Constructor: 後処理最適化
最終的な調整として、パス拡張とゴール周辺の特別処理を実行します。

#### 基本的なパス拡張
```cpp
// PATH隣接セルの条件付き拡張
bool _should_convert_to_path(const Board& board, int ei, int ej);
```

**条件**: 元々隣接していたPATH以外で、隣接するPATHが存在しない

#### ゴール周辺マンハッタン距離2の特別処理
```cpp
// ゴール周辺マンハッタン距離2の特別処理
void _process_goal_adjacent_empty_cells(Board& board);
```

**処理前の例**:
```
.****.
....**
..##.*
.#.X#.
...#..
......
```

**処理後の例**:
- [2,4]がXからマンハッタン距離2で、[1,4],[1,5],[2,5]が全てPATH → [2,4]をPATHに変更
- [1,3]がXからマンハッタン距離2で、[0,3],[0,4],[1,4]が全てPATH → [1,3]をPATHに変更

```
.****.
...***
..##**
.#.X#.
...#..
......
```

#### 最終処理
- 残りの全EMPTY セルをNEW_TREE に変換
- 完全な迷路構造の完成

## 評価システム

### BoardChecker: ペナルティ計算
BoardCheckerは構築された盤面の品質を評価するクラスです。

```cpp
class BoardChecker {
    int check(const Board& board) {
        // 1. S→Xの最短パス探索
        auto shortest_path = _find_shortest_path(board);
        // 2. ゴール周辺の木とパスの隣接性評価
        int penalty = _calculate_penalty(board, shortest_path);
        return penalty;
    }
};
```

#### ペナルティ計算の詳細プロセス

**1. 最短パス探索**
スタート（S）からゴール（X）への最短パスをBFSで探索します。

例：最短パス発見の例
```
....#@@@#@S#........
###.#@#@@#..###.###
#...#@@#..#.#.......
###..#@.#.#..###.###
####.#@#..#.####....
.....#@#.#..#....###
###.#@@#..#.####.###
###.#@#..#...###....
....#@#.#..##....###
###.#@#.##..####.###
###.#@#...#..#.....#
....#@###.#.####.###
###.#@@@#.#.#....###
###..##@#.#..###....
....#@@@#.##..#..###
###.#@#.#...#.##.###
###.#@@#X##.#..#....
....#.@@.#..#.#..###
###.#.#.##.....#.###
......#.#..#.###....
```
- `@`: 最短パス上のセル
- Xに隣接する`@`は除外（ペナルティ計算対象外）

**2. ゴール周辺の木評価**
ゴール（X）の4方向について、最初に見つかる木（`#`または`T`）を特定し、最短パスとの隣接性をチェックします。

**良い例（ペナルティ=1）**:
```
....
.@#.  ← この木は@（パス）と隣接 → ペナルティなし
#X#.
.@#.  ← この木も@（パス）と隣接 → ペナルティなし
....
```
右方向の木のみが@と隣接していない → ペナルティ=1

**悪い例（ペナルティ=3）**:
```
....
..#.  ← この木は@（パス）と隣接せず → ペナルティ+1
.X#.  ← 右方向の木も隣接せず → ペナルティ+1
..#.  ← この木も隣接せず → ペナルティ+1
....
```
3方向の木が全て@と隣接していない → ペナルティ=3

**3. ペナルティスコア**
- **0**: 全方向の木が最短パスと隣接（理想的）
- **1-3**: 一部の木が隣接していない
- **999**: 最短パスが存在しない（到達不可能）

### BoardSimulator: 実際の移動シミュレーション
BoardSimulatorは冒険者の実際の行動をシミュレートし、移動回数を計算します。

```cpp
class BoardSimulator {
    int simulate(const Board& board) {
        // 冒険者の実際の行動をシミュレート
        // - 4方向視線による探索
        // - BFSによる最短経路移動
        // - ターゲット動的変更
        return turn; // 移動回数を返す
    }
};
```

#### シミュレーション動作詳細

**1. 視線による探索**
冒険者は現在位置から4方向（上下左右）に視線を伸ばし、木（`T`、`#`）に遮られるまでのセルを探索します。

**視線の例**:
```
.....*..
..T..*..  ← 木で視線がブロック
...S.#..  ← S:冒険者位置、#:木により右方向の視線停止
.....*..
..X.....  ← X:ゴール（まだ未発見）
```

**2. ターゲット選択と経路計算**
- **ゴール発見前**: ランダムな未探索セルをターゲット
- **ゴール発見後**: 即座にゴールをターゲットに変更
- **経路計算**: 既知セルのみを使用したBFS最短経路

**3. 移動とターゲット更新**
- 計算された最短経路に従って1セルずつ移動
- 移動先で新たに視線探索を実行
- 新たなセルが発見されると、ターゲットへの経路を再計算

#### 実際のシミュレーション例

**初期状態**（冒険者視点）:
```
?????
??S??  ← 冒険者初期位置、周囲のみ既知
?????
```

**数ターン後**（探索が進んだ状態）:
```
....#...#.S#....
###.#.#...#..###
#...#..#..#.#...
###..#..#.#..###
?????????#??????  ← まだ未探索領域
????????????????
```

**最終的な移動例**:
1. ランダムターゲットに向けて移動
2. より多くのセルを探索
3. ゴール（X）を発見
4. ゴールへの最短経路で移動
5. ゴール到達（シミュレーション終了）

**移動回数**: 効率的な盤面では短く、複雑な迷路では長くなる

## パフォーマンス最適化

### コンパイル最適化
```cpp
#pragma GCC optimize "-O3,omit-frame-pointer,inline,unroll-all-loops,fast-math"
```

### 評価数制限
```cpp
static constexpr int NUM_EVALUATIONS = 7;  // 評価回数を削減
const double TOTAL_LIMIT = 1.8;            // 安全マージン付き制限時間
```

### 最小ペナルティフィルタリング
```cpp
// 最小ペナルティのボードのみ評価
if(penalty > min_penalty) break;
```

## 実行結果例

### 実際の実行ログ
```
Generated 238 candidates in phase 1
Sorted candidates by penalty (min=3, max=999)
Evaluating only candidates with minimum penalty: 3
New best: score=120, penalty=3, paths=209
New best: score=360, penalty=3, paths=208
Evaluated 20 candidates in phase 3
Best score: 360
```

### 最終出力盤面（例）
実際に出力される最適解の盤面例：
```
....#...##?#...#....
###.#.#..##..###.###
#...#..#..S.#.......
###..#..#.#..###.###
####.#.#..#.####....
.....#.#.#..#....###
###.#..#..#.####.###
###.#.#..#...###....
....#.#.#..##....###
###.#.#.##..####.###
###.#.#...#..#.....#
....#.###.#.####.###
###.#...#.#.#....###
###..##.#.#..###....
....#...#.##..#..###
###.#.#.#...#.##.###
###.#..#X##.#..#....
....#....#..#.#..###
###.#.#.##.....#.###
......#.#..#.###....
```

この盤面は：
- **ペナルティ**: 3（最小値）
- **PATH数**: 208
- **スコア**: 360ターン
- **特徴**: 複雑な分岐構造により冒険者を効率的に迷わせている

## アルゴリズムの特徴

### 長所
1. **多段階最適化**: 段階的に解の品質を向上
2. **効率的評価**: ペナルティフィルタリングにより計算量削減
3. **多様性確保**: ランダム要素により局所最適回避
4. **実用的時間管理**: 制限時間内で確実に解を出力

### 設計思想
1. **品質重視**: ペナルティが最小のボードに集中
2. **PATH数優先**: 同一ペナルティ内ではより多くのPATHを持つボードを優先
3. **安全性確保**: 時間制限とエラー処理の徹底

## 技術的詳細

### 座標系
- **(i, j) = (行, 列)** の0-indexed座標系
- **1次元変換**: `index = i * n + j`

### セル状態定義
```cpp
enum Cell : int {
    EMPTY = 0,      // '.' 空きセル
    TREE = 1,       // 'T' 初期木
    PATH = 2,       // '*' パス
    PATH_2 = 3,     // '@' 一時パス
    NEW_TREE = 4,   // '#' 新規配置木
    START = 5,      // 'S' スタート
    GOAL = 6,       // 'X' ゴール
    HIDDEN_TREE = 7 // 'H' 隠し木
};
```

このソリューションは、複雑な組み合わせ最適化問題に対して、ヒューリスティックアルゴリズムと厳密評価を組み合わせた実用的なアプローチを提供しています。