# AHC054 詳細実装仕様書

## 問題設定

problem.mdに記載されている内容の要点：
- N×Nの森で冒険者が花を探す
- 冒険者は未確認マスを空きマスと仮定して最短経路で移動
- トレントを配置して冒険者を迷わせ、移動回数を最大化する
- ただし花への到達経路は必ず確保する必要がある

# 凡例

`.`は何も置かれていない道
`X`は花の位置
`S`はスタート地点
`T`は最初に置かれている木
`#`は追加で置かれた木
`*`はパスとして使用する予定の道

上からx番目、左からy番目の座標を[x,y]と示し、0-indexedとする

# 全体的な方針

インタラクティブ要素は使わずに、初期配置の木の位置のみ決める
追加する木の座標を出力した後は`-1`を出力して、プログラムを終了させる

## 初期状態

```
........T.ST........
..............T.....
T...................
........T...........
...T................
.....T..............
..........T.........
....................
......T.T.........T.
....T..........T..T.
.T..T........T.....T
........T...........
....................
.....TT.............
.................T..
....................
........X.T.........
............T.....T.
....................
...........T.TTT....
```

## Step1. 花Xの周りの設定

花Xの周りに木をおく。
花の周りの配置方法のうち、以下のパターンから1つを選ぶようにする
`*`は木をおいていけない箇所である。この位置にすでに`T`が立っている場合や、外壁になっているような場合は採用しない

### パターン1

```
.#.
**#
#X#
.#.
```

### パターン2

```
.#.
#**
#X#
.#.
```

### パターン3

```
.#.
#X#
**#
.#.
```

### パターン4

```
.#.
#X#
#**
.#.
```

### パターン5

```
.*#.
#*X#
.##.
```

### パターン6

```
.##.
#*X#
.*#.
```

### パターン7

```
.#*.
#X*#
.##.
```

### パターン8

```
.##.
#X*#
.#*.
```

### 処理後の状態

パターン1を採用した場合

```
........T.ST........
..............T.....
T...................
........T...........
...T................
.....T..............
..........T.........
....................
......T.T.........T.
....T..........T..T.
.T..T........T.....T
........T...........
....................
.....TT.............
........#........T..
.........#..........
.......#X#T.........
........#...T.....T.
....................
...........T.TTT....
```

## Step2. 左端と右端に縦の道を作る

下のように、左側と右側に対して道を作る

```
..*.....T.ST.....*..
..*...........T..*..
T.*..............*..
..*.....T........*..
..*T.............*..
..*..T...........*..
..*.......T......*..
..*..............*..
..*...T.T........*T.
..*.T..........T.*T.
.T*.T........T...*.T
..*.....T........*..
..*..............*..
..*..TT.........**..
..*.....#.......*T..
..*......#......**..
..*....#X#T......*..
..*.....#...T....*T.
..*..............*..
..*........T.TTT.*..
```

左側の構築方法を示す。右側も左右対称として同様である

- 下記のパスが満たすべき条件を満たす必要がある
- Y<=1の領域には入っていけない（Y>=2の範囲を動くこと）
- なるべく左側に寄せた1本道を作る

上の条件を満たすために、下記のDP+経路復元アルゴリズムで実装する
dp[i][l][r] := i行目のセルのうち、l<=j<=rの領域がパスとなる最小コスト
l,rは0<=l,r<=8程度を考えれば良い（全範囲とってもO(N^3)なので計算は間に合う）

- 初期状態
    - [0,l]から[0,r]の範囲が全て`.`ならば
        - dp[0][l][r] = r + penalty (l<2の場合はpenalty=6を加算)
    - それ以外
        - dp[0][l][r] = inf

- 遷移（2つのパターン）
    - パターン1: (l,r)から(r,r2)への遷移
        - 前の行の最小コストを事前計算: min_r = min(dp[i-1][l][r] for l <= r)
        - dp[i][r][r2] = min(dp[i][r][r2], min_r + r2 + penalty)
    - パターン2: (l,r)から(l2,r)への遷移
        - 前の行の最小コストを事前計算: min_l = min(dp[i-1][l][r] for l <= r)
        - dp[i][l2][r] = min(dp[i][l2][r], min_l + l2 + penalty)

- 復元方法
    - 親ノード情報を記録して正確な経路復元を実行
    - 最終行から逆算して経路を構築



## Step3. 左端から開始して一本道を作る

完成系のイメージ

```
..***...T.ST****.*..
..*.*.***..**.T*.*..
T.*.*.*.**.*.***.*..
..*.*.*.T*.*.*...*..
..*T*.*..*.*.*...*..
..*.*T*..*.*.*...*..
..*.*.**.*T*.*...*..
..*.*..*.*.*.*...*..
..*.**T*T*.*.*...*T.
..*.T*.*.*.*.**T.*T.
.T*.T*.*.*.*.T**.*.T
..*.**.*T*.***.*.*..
..*.*..*.*...*.*.*..
..*.*TT*.***.*.***..
..*.*.**#..*.*..*T..
..*.*.*..#.*.*..**..
..*.*.*#X#T*.*...*..
..*.*.*.#..*T*...*T.
..*.*.*....***...*..
..*.***....T.TTT.*..
```

### 開始パスの選択
- iの昇順または降順にみて、下記の条件を満たす`*`を開始パスとする
    - i行目の中で、[i,j]=`*`かつ[i,j+1]=`.`となる最小のjである
    - [i+1,j+1]!=`*`である（次の行で道を延ばせる）

### 下向きパス構築（iが昇順）
- 開始パスから開始してi=N-1に到達するパスを下向きにStep2のDP+経路復元で求める
- Step2との相違点：
    - **動的範囲設定**: l,rの範囲は行ごとに変える
    - **範囲計算**: i行目にある`*`のうち最も右側にあるセルのjの値をj_maxとした時
        - 通常: `j_max + 2 <= l, r <= min(N-1, j_max + 10)`
        - 開始パスがある行のみ: `j_max + 1 <= l, r <= min(N-1, j_max + 10)`
    - **制約**: Step2の右端のパスは除外して考える
    - **ペナルティ**: PENALTYはかけない
- 仮に復元したパスがi=N//2にも到達できていないような場合は、開始点を下げて再度実行する

### 上向きパス構築（iが降順）
- 経路復元でパスを復元し、盤面を更新する
- 昇順と降順を入れ替えた上で、同じ流れで上向きのパスを構築する

### 終了条件
- このアルゴリズムを繰り返した時、最終的にはStep2で構築した右側のパスと接触する
- そのような状態になったら終了する



## Step4. パスとスタート、パスとXをつなぐ

```
..***...T.*T****.*..
..*.*.***.***.T*.*..
T.*.*.*.**.*.***.*..
..*.*.*.T*.*.*...*..
..*T*.*..*.*.*...*..
..*.*T*..*.*.*...*..
..*.*.**.*T*.*...*..
..*.*..*.*.*.*...*..
..*.**T*T*.*.*...*T.
..*.T*.*.*.*.**T.*T.
.T*.T*.*.*.*.T**.*.T
..*.**.*T*.***.*.*..
..*.*..*.*...*.*.*..
..*.*TT*.***.*.***..
..*.*.**#..*.*..*T..
..*.*.***#.*.*..**..
..*.*.*#X#T*.*...*..
..*.*.*.#..*T*...*T.
..*.*.*....***...*..
..*.***....T.TTT.*..
```

S,Xそれぞれについて、Step3で構築したパスに接続するように`*`を追加する
DFS + 経路復元などのアルゴリズムを使う

## Step5. 分岐路の作成

パスに対してSからの距離が遠い順に、以下のように貪欲に分岐を生やしていく

変更前

```
..*.
..*.
..*.
..*.
..*.
```

1. 現在見ている対象のパス（Cとする）に隣接する点(Aとする)とその先にある点(Bとする)の双方が`.`であるかを確認する
2. 上の点Aと点Bに隣接している点のうち、C以外で`*`であるものがないことを確認する
3. 条件を満たすようであれば、AとBを`*`に変更する。その上で、AとBに隣接する`.`となっている点を`#`に更新する

変更後

```
..*.
..*.
..*.
##*.
***.
```

全体へ適用した後

```
##***...T.*T****.***
***.*.***.***.T*.*##
T#*.*.*.**.*.***.***
***.*.*.T*.*.*...*##
##*T*.*..*.*.*.*****
***.*T*..*.*.*...*##
##*.*.**.*T*.*.*****
***.*..*.*.*.*...*##
##*.**T*T*.*.*.***T.
***.T*.*.*.*.**T.*T.
#T*.T*.*.*.*.T**.*.T
***.**.*T*.***.*.***
##*.*..*.*...*.*.*##
***.*TT*.***.*.*****
##*.*.**#..*.*..*T##
***.*.***#.*.*..****
##*.*.*#X#T*.*...*##
***.*.*.#***T*...*T#
##*.*.*####***.*****
***.*****#.T.TTT.*##
```

- 分岐の生成がうまくいったとき、Sからの距離をdとした時にスコアがd加算されるとする
- この総スコアが大きい盤面ほど良い盤面と評価する

## Step6. 後処理

`*`に隣接する`.`に対して、以下の条件を満たすときに隣に`*`を追加して良い。操作順は問わない

- 対象のセルが`.`である
- 元々隣接していた`*`以外で、隣接する`*`が存在しない

完成系

```
##***.*.T.*T****.***
***.*.***.***.T*.*##
T#*.*.*.**.*.***.***
***.*.*.T*.*.*...*##
##*T*.*..*.*.*.*****
***.*T*..*.*.*...*##
##*.*.**.*T*.*.*****
***.*..*.*.*.*...*##
##*.**T*T*.*.*.***T.
***.T*.*.*.*.**T.*T.
#T*.T*.*.*.*.T**.*.T
***.**.*T*.***.*.***
##*.*..*.*...*.*.*##
***.*TT*.***.*.*****
##*.*.**#*.*.*..*T##
***.*.***#**.*.*****
##*.*.*#X#T*.*.*.*##
***.*.*.#***T*...*T#
##*.*.*####***.*****
***.*****#.T*TTT.*##
```

- 上で残った全ての`.`を`#`に置換する


# 全体の流れ
上のアルゴリズムの1サイクルはO(N^2)~O(N^3)程度で終わるはずであり高速である。
時間いっぱい上のサイクルを回し、Step5における盤面スコアが最も良いものを採用する。
結果を見ながらランダム要素を加えていくことで多様な盤面を確保する


# パスの構築方法

## パスが満たすべき条件

### 閉路ができないこと

連結しているパス`*`について、隣接している点同士をエッジとした時に閉路ができてはいけない
パスグラフを構築する際は、移動元以外の`*`が移動先に隣接していないようにすることが条件となる

- ダメな例

```
.*.
.**
.**
.*
```

```
.***
.*.*
.*.*
****
*.*.
```

### 非連結なパスがあること

パス`*`同士は`*`を通じて辿ることができる

ダメな例

```
.*.
.*.
..*
..*
```

