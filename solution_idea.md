# AHC054 詳細実装仕様書

## 問題設定

problem.mdに記載されている内容の要点：
- N×Nの森で冒険者が花を探す
- 冒険者は未確認マスを空きマスと仮定して最短経路で移動
- トレントを配置して冒険者を迷わせ、移動回数を最大化する
- ただし花への到達経路は必ず確保する必要がある

# 凡例

`.`は何も置かれていない道
`X`は花の位置
`S`はスタート地点
`T`は最初に置かれている木
`#`は追加で置かれた木
`*`はパスとして使用する予定の道

上からx番目、左からy番目の座標を[x,y]と示し、0-indexedとする

# 全体的な方針

インタラクティブ要素は使わずに、初期配置の木の位置のみ決める
追加する木の座標を出力した後は`-1`を出力して、プログラムを終了させる

## 初期状態

```
........T.ST........
..............T.....
T...................
........T...........
...T................
.....T..............
..........T.........
....................
......T.T.........T.
....T..........T..T.
.T..T........T.....T
........T...........
....................
.....TT.............
.................T..
....................
........X.T.........
............T.....T.
....................
...........T.TTT....
```

## Step1. 花Xの周りの設定

花Xの周りに木をおく。
花の周りの配置方法のうち、以下のパターンから1つを選ぶようにする
`*`は木をおいていけない箇所である。この位置にすでに`T`が立っている場合や、外壁になっているような場合は採用しない

### パターン1

```
.#.
**#
#X#
.#.
```

### パターン2

```
.#.
#**
#X#
.#.
```

### パターン3

```
.#.
#X#
**#
.#.
```

### パターン4

```
.#.
#X#
#**
.#.
```

### パターン5

```
.*#.
#*X#
.##.
```

### パターン6

```
.##.
#*X#
.*#.
```

### パターン7

```
.#*.
#X*#
.##.
```

### パターン8

```
.##.
#X*#
.#*.
```

### 処理後の状態

パターン1を採用した場合

```
........T.ST........
..............T.....
T...................
........T...........
...T................
.....T..............
..........T.........
....................
......T.T.........T.
....T..........T..T.
.T..T........T.....T
........T...........
....................
.....TT.............
........#........T..
.........#..........
.......#X#T.........
........#...T.....T.
....................
...........T.TTT....
```

## Step2. 左端と右端に縦の道を作る

下のように、左側と右側に対して道を作る

```
..*.....T.ST.....*..
..*...........T..*..
T.*..............*..
..*.....T........*..
..*T.............*..
..*..T...........*..
..*.......T......*..
..*..............*..
..*...T.T........*T.
..*.T..........T.*T.
.T*.T........T...*.T
..*.....T........*..
..*..............*..
..*..TT.........**..
..*.....#.......*T..
..*......#......**..
..*....#X#T......*..
..*.....#...T....*T.
..*..............*..
..*........T.TTT.*..
```

左側の構築方法を示す。右側も左右対称として同様である
- [0,2]を出発点とする（[0,2]が`.`でない場合は右に移動し、`.`である点を探す）出発点を`*`にする
- バックトラックDFSのアルゴリズムで、X=N-1となる点まで移動する。
    - ただし、Y<=1の領域には入っていけない（Y>=2の範囲を動くこと）
    - 左下右の優先順位でDFSしながら進む。下記の条件を満たすときに移動できる
        - 移動先が`.`である
        - 移動元以外の`*`が移動先に隣接していない（閉路ができたら困るので）
    - 移動先を`*`に更新し、移動する。
    - どの隣接するセルに移動することができない場合は現在の地点を`.`に戻し、バックトラックする

## Step3. 左端から開始してDFSで一本道を作る

完成系のイメージ

```
..***...T.ST****.*..
..*.*.***..**.T*.*..
T.*.*.*.**.*.***.*..
..*.*.*.T*.*.*...*..
..*T*.*..*.*.*...*..
..*.*T*..*.*.*...*..
..*.*.**.*T*.*...*..
..*.*..*.*.*.*...*..
..*.**T*T*.*.*...*T.
..*.T*.*.*.*.**T.*T.
.T*.T*.*.*.*.T**.*.T
..*.**.*T*.***.*.*..
..*.*..*.*...*.*.*..
..*.*TT*.***.*.***..
..*.*.**#..*.*..*T..
..*.*.*..#.*.*..**..
..*.*.*#X#T*.*...*..
..*.*.*.#..*T*...*T.
..*.*.*....***...*..
..*.***....T.TTT.*..
```
- Step2で作成した端の道のうち1点をスタート地点ととり、DFSで一本道を構築する。今回は左端の道の点をスタートとして右端へ移動するものとする
- 初期位置を[x,y]としたとき、
    - x < N/2ならば初めは下向きに進む
    - x >= N/2ならば初めは上向きに進む

- バックトラックDFSのアルゴリズムで1本の道を構成する
    - Y<=1の領域には入っていけない（Y>=2の範囲を動くこと）
    - 現在の地点から下記の優先順位でDFSしながら進む。
        - 進行方向が上向きの時は左→上→右の優先度
        - 進行方向が下向きの時は左→下→右の優先度
    - 下記の条件を満たすときに移動できる
        - 移動先が`.`である
        - 移動元以外の`*`が移動先に隣接していない（閉路ができたら困るので）
            - ただしStep2で構成した右端のパスと繋がるのはOK 
    - 移動先を`*`に更新し、移動する。
    - どの隣接するセルに移動することができない場合は現在の地点を`.`に戻し、バックトラックする
    - 右端の道のうちのどこかのパスに到達することができれば終了する

## Step4. パスとスタート、パスとXをつなぐ

```
..***...T.*T****.*..
..*.*.***.***.T*.*..
T.*.*.*.**.*.***.*..
..*.*.*.T*.*.*...*..
..*T*.*..*.*.*...*..
..*.*T*..*.*.*...*..
..*.*.**.*T*.*...*..
..*.*..*.*.*.*...*..
..*.**T*T*.*.*...*T.
..*.T*.*.*.*.**T.*T.
.T*.T*.*.*.*.T**.*.T
..*.**.*T*.***.*.*..
..*.*..*.*...*.*.*..
..*.*TT*.***.*.***..
..*.*.**#..*.*..*T..
..*.*.***#.*.*..**..
..*.*.*#X#T*.*...*..
..*.*.*.#..*T*...*T.
..*.*.*....***...*..
..*.***....T.TTT.*..
```

S,Xそれぞれについて、Step3で構築したパスに接続するように`*`を追加する
DFS + 経路復元などのアルゴリズムを使う

## Step5. 分岐路の作成

パスに対してSからの距離が遠い順に、以下のように貪欲に分岐を生やしていく

変更前

```
..*.
..*.
..*.
..*.
..*.
```

1. 現在見ている対象のパス（Cとする）に隣接する点(Aとする)とその先にある点(Bとする)の双方が`.`であるかを確認する
2. 上の点Aと点Bに隣接している点のうち、C以外で`*`であるものがないことを確認する
3. 条件を満たすようであれば、AとBを`*`に変更する。その上で、AとBに隣接する`.`となっている点を`#`に更新する

変更後

```
..*.
..*.
..*.
##*.
***.
```

全体へ適用した後

```
##***...T.*T****.***
***.*.***.***.T*.*##
T#*.*.*.**.*.***.***
***.*.*.T*.*.*...*##
##*T*.*..*.*.*.*****
***.*T*..*.*.*...*##
##*.*.**.*T*.*.*****
***.*..*.*.*.*...*##
##*.**T*T*.*.*.***T.
***.T*.*.*.*.**T.*T.
#T*.T*.*.*.*.T**.*.T
***.**.*T*.***.*.***
##*.*..*.*...*.*.*##
***.*TT*.***.*.*****
##*.*.**#..*.*..*T##
***.*.***#.*.*..****
##*.*.*#X#T*.*...*##
***.*.*.#***T*...*T#
##*.*.*####***.*****
***.*****#.T.TTT.*##
```

- 分岐の生成がうまくいったとき、Sからの距離をdとした時にスコアがd加算されるとする
- この総スコアが大きい盤面ほど良い盤面と評価する

## Step6. 後処理

`*`に隣接する`.`に対して、以下の条件を満たすときに隣に`*`を追加して良い。操作順は問わない

- 対象のセルが`.`である
- 元々隣接していた`*`以外で、隣接する`*`が存在しない

完成系

```
##***.*.T.*T****.***
***.*.***.***.T*.*##
T#*.*.*.**.*.***.***
***.*.*.T*.*.*...*##
##*T*.*..*.*.*.*****
***.*T*..*.*.*...*##
##*.*.**.*T*.*.*****
***.*..*.*.*.*...*##
##*.**T*T*.*.*.***T.
***.T*.*.*.*.**T.*T.
#T*.T*.*.*.*.T**.*.T
***.**.*T*.***.*.***
##*.*..*.*...*.*.*##
***.*TT*.***.*.*****
##*.*.**#*.*.*..*T##
***.*.***#**.*.*****
##*.*.*#X#T*.*.*.*##
***.*.*.#***T*...*T#
##*.*.*####***.*****
***.*****#.T*TTT.*##
```

- 上で残った全ての`.`を`#`に置換する


# 全体の流れ
上のアルゴリズムの1サイクルはO(N^2)~O(N^3)程度で終わるはずであり高速である。
時間いっぱい上のサイクルを回し、Step5における盤面スコアが最も良いものを採用する。
結果を見ながらランダム要素を加えていくことで多様な盤面を確保する


# パスの構築方法

## パスが満たすべき条件

### 閉路ができないこと

連結しているパス`*`について、隣接している点同士をエッジとした時に閉路ができてはいけない
パスグラフを構築する際は、移動元以外の`*`が移動先に隣接していないようにすることが条件となる

- ダメな例

```
.*.
.**
.**
.*
```

```
.***
.*.*
.*.*
****
*.*.
```

### 非連結なパスがあること

パス`*`同士は`*`を通じて辿ることができる

ダメな例

```
.*.
.*.
..*
..*
```

