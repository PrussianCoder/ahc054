# Treant’s Forest 壁構築 仕様書（実装可レベル）

> 目的：**複数の盤面構築法**（静的配置）＋**ターン中の追加配置**（動的配置）を、共通骨格の上で差し替え可能に実装できるようにする。
> 本仕様書だけで AtCoder AHC054「A - Treant’s Forest」に提出可能な解を作れる粒度で記述する。

---

## 0. 前提・用語

* 盤面サイズ：$20 \le N \le 40$
* 座標：$(i,j)$（0-index），入口 $s=(0,\lfloor N/2\rfloor)$，花 $t=(t_i,t_j)$
* 真の地図 `B[i][j]`：`'.'`=空き, `'T'`=木（**初期入力で完全に分かる**）
* **未確認**・**確認済み**：ジャッジ側の視界状態。こちらは各ターンで**増分リスト**を受け取る
* 暫定地図：未確認をすべて空きとみなす仮地図（冒険者の意思決定で用いられる）
* 出力：各ターン開始時に、**未確認**かつ空きだったマスへ木を**追加**可能（不可逆）
* 重要制約：**常に** s から t への空き経路が**少なくとも1本**存在すること（破ると WA）

---

## 1. 全体構成（共通実装）

### 1.1 モジュール構成（推奨）

* `Grid`：入力地形と可変地形（木追加後）を保持
* `RevealState`：確認済みフラグ `revealed[i][j]`
* `Connectivity`：BFS/DSU による s–t 連結チェック
* `Raycaster`：直線方向の「次に当たる木」までのセル群を返す
* `Planner`：壁候補の生成（静的・動的）。**戦略ごとにクラス化**し差替
* `TurnLoop`：I/O 処理、各ターンの追加配置→出力

### 1.2 データ表現

* `B[i][j] : char`  … 現在の真の地図（我々が木を足すたび `'.'->'T'` に更新）
* `revealed[i][j] : bool`  … 確認済み
* `cannot_place[i][j] : bool`  … 置けない場所（`revealed` or もともと `'T'`）
* 方向ベクトル `DIRS = {Up:(-1,0), Down:(1,0), Left:(0,-1), Right:(0,1)}`

### 1.3 共通ユーティリティ

* `in_bounds(i,j)`：境界判定
* `is_empty(i,j)`：`B[i][j]=='.'`
* `neighbors4(i,j)`：4近傍列挙
* `bfs_reachable(src, dst, B)`：`'.'`のみで到達可能か（bool または経路も返す）
* `first_unrevealed_empty_on_ray(p, dir)`：位置 `p` から `dir` に進み，
  最初に出会う**未確認の空き**セル（なければ `None`）
* `safe_to_place(cells)`：仮に `cells` を `'T'` にしたとき **s–t連結が保たれるか**
  実装：

  1. 一時的に `B` を更新（メモリ or 差分）
  2. `bfs_reachable(s,t,B_tmp)`
  3. 元に戻す
     ※ $N\le 40$ なので BFS 1回 $O(N^2)$ は十分速い

### 1.4 I/O とループ

初期入力：

```
N ti tj
b_0
...
b_{N-1}
```

ターンループ（Python擬似）：

```python
# 準備
read N, ti, tj; read B rows
revealed = [[False]*N for _ in range(N)]
revealed[s_i][s_j] = True

# 静的配置（後述）で初期の追加リスト S0 を作成・安全化して出力
place_and_output(S0)

while True:
    pi, pj = read()
    n, x0,y0, ... = read()
    for k in range(n): revealed[xk][yk] = True

    if (pi, pj) == (ti, tj): break  # 終了

    # 動的配置：Planner が現在の (B, revealed, p, 直近の増分) から候補を返す
    C = planner.dynamic_candidates(pi, pj, newly_revealed_list)

    # フィルタリング：未確認 && '.' && 安全
    M = filter_unrevealed_empty(C)
    M = take_until_safe(M)  # s–t 断絶しない範囲まで
    place_and_output(M)     # flush 必須
```

出力形式：

```
m x0 y0 x1 y1 ... xm-1 ym-1
```

* **改行＋flush 必須**
* 実務上の上限：I/O 負荷対策で 1 ターンあたり **\~50 個程度**に抑えるのが無難（可変）

---

## 2. 静的配置（初期盤の作り方）

> ここで言う「静的」は **ターン0の一括施工**。以降は「動的」に少量を追加。

### 2.1 静的配置の共通枠

1. **候補集合 $C$ を生成**（戦略別に作る。入口 s と花 t は候補から除外）
2. **安全化パス**（s–t を必ず通す）

   * `while not bfs_reachable(s,t, B with C as T):`

     * 「**元の B** での最短路 $P_0$」を BFS で求め、`C` と交差するセルを `C` から除外
   * 結果 `C*` は s–t を絶対に遮らない
3. **設置**：`C*` を `'T'` に確定し `B` 更新（ただし**未確認**にしか置けない制約は満たす。初手は s 以外未確認なので概ねOK）

> 以降は、各戦略ごとに **$C$ の作り方**だけを差し替える。

---

## 3. 各構築法（静的）

### 3.1 蛇行回廊（One-path Snake）

**狙い**：入口→花の**一本道だけ**を残し，他は極力ふさぐ

**候補 $C$ の生成**：

1. `P0 = bfs_shortest_path(B, s, t)` を取得（'.' のみ）
2. 「蛇行スケルトン」を全盤に用意（例：行ごとに左右往復の**蛇型順序** `Z` を定義）
3. `P0` を**優先走路**として固定し、`Z` の順に\*\*P0 以外の `'.'`\*\*を `C` に入れる

   * ただし `P0` の**隣接 1 マス**は**空け**ておき、後で動的カーテンに使える余白を確保
4. **安全化パス**（§2.1）

**注意**：既存 `'T'` で蛇行が切れても問題なし。最短路 `P0` だけ通ればよい。

---

### 3.2 玉ねぎ防壁（Onion Rings）

**狙い**：花の周囲を**同心正方リング**で囲み、各リングに**扉1つ**を設ける（扉位置はリングごとに回転）

**候補 $C$ の生成**：

1. チェビシェフ距離 $r=1,2,\dots,R$（$R \approx \max(N/2, |t-s|)$ まで）
   各 $r$ の**外周** $\{(i,j)\mid \max(|i-t_i|,|j-t_j|)=r\}$ を列挙
2. その外周のうち `'.'` を `C` に入れる。ただし**扉セル $g_r$** を1つ決めて **除外**

   * $g_r$ の決定：`bfs_dist_from_s` を前計算し，**距離が単調に減る方向**へ扉位置を「回転」
   * 例：`g_r` の方位を (上,右,下,左) と交互にずらす
3. **安全化パス**

**実装ポイント**：

* 既存 `'T'` がある辺はスキップ
* 隣り合う扉が**直線で貫通**しないよう、扉方位を**ずらす**

---

### 3.3 多段ゲート柵（Multi-Fence with Alternating Gates）

**狙い**：横（もしくは縦）柵を複数段置き、**穴（ゲート）位置を交互**にずらして折返しを強制

**候補 $C$ の生成**：

1. `fence_rows = {r0, r1, r2, ...}` を等間隔（例：3〜4マス）に選ぶ
   もしくは `bfs_dist_from_s` の同距離層で近い行を選ぶ
2. 各行 $r$ について、**全ての `'.'`** を `C` に入れる。ただし**ゲート列 $g(r)$** は除外

   * $g(r)$ は `(左端+Δ) mod K` で段ごとにシフト（交互配置）
3. **安全化パス**

**実装ポイント**：

* 行を横断する `'T'` により柵が分割されてもOK
* ゲートの上下に**短い幕**（1〜2マス）を空けておくと後の動的差し込みが効く

---

### 3.4 渦巻（Spiral Corridor）

**狙い**：外周から t へ向けて**1マス幅**のスパイラル状に**空きライン**を残し，他を埋める

**候補 $C$ の生成**：

1. 盤面長方形を外側から内側へと「層」を縮め，**回廊ライン $R$**（1セル幅）を決める

   * 入口 s と花 t が**同じ回廊**で結ばれるように開始層と方向（時計/反時計）を選択
2. `'.'` のうち **回廊 $R$ 以外**を全て `C` に入れる

   * ただし回廊の**両脇**は 1マス空け推奨（動的幕の余地）
3. **安全化パス**

**実装ポイント**：既存 `'T'` で回廊が途切れたら、回廊の**ブリッジ**としてその区間だけ `R` を最短路 `P0` に置換

---

### 3.5 クシ型（Comb: Trunk + Dead-end Teeth）

**狙い**：長い幹道＋多数の袋小路（歯）で、**目的地再抽選**を狙う

**候補 $C$ の生成**：

1. `P0`（s–t最短路）を**幹**とする。幹の**片側**に限定して歯を生やす
2. 歯は幹と直交方向へ **長短織り交ぜ**て延ばし、**歯以外**の `'.'` を `C` に入れる

   * 歯の**入口1マス**は除外（動的幕）
   * 入口側は短く密、奥側は長く疎を目安
3. **安全化パス**

**実装ポイント**：歯どうしが裏で繋がらないように**歯間に1列空白**を残す

---

### 3.6 二重扉エアロック（Double-Gate Airlocks）

**狙い**：［壁］—（1マス室）—［壁］の**小部屋を連続**させ、覗かれた瞬間に次室向こう側を**後追いで閉じる**

**候補 $C$ の生成**：

1. s→t の導線上に等間隔で**2重柵**を配置（`C`）
2. 各小部屋の**扉候補**（1マス）は `C` から除外しておく（動的に閉じるため）
3. **安全化パス**

**実装ポイント**：扉の向きを左右交互にし、直通視界を避ける

---

### 3.7 遮光ピラー格子（Pillar Lattice）

**狙い**：視界（レイ）を常に短くするため、**市松/格子状**に 1マス柱（木）を撒く

**候補 $C$ の生成**：

1. 例えば `(i%3==1 && j%3==1)` の全 `'.'` を `C` に入れる
2. s–t の**通り道帯**（幅2〜3）だけは柱を**除外**
3. **安全化パス**

**実装ポイント**：柱密度は 2〜3 マス周期が目安。高密度にするほど視界は短い

---

### 3.8 花の影（Shade the Target）

**狙い**：t の**上下左右**へ短い梁を出し、**最初に当たる木**を t の手前に作る

**候補 $C$ の生成**：

1. t から各方向に向けて，最短で**1〜2マス先**に遮光梁（`'.'` のみ）を配置候補 `C` に追加
2. 外周は **3.1/3.3/3.4** などの誘導構築と組み合わせて全体像を作る
3. **安全化パス**

**実装ポイント**：梁は**一直線で t を露わにしない**位置に置く（既存木と組み合わせて手前止め）

---

## 4. 動的配置（毎ターンの追加）

> 動的は**小出し**が基本。**視界（レイ）を止める“幕”** と **誘導回廊の維持** を優先。
> 予算目安：**1ターン 0〜50 マス**（I/O 次第で調整）

### 4.1 共通ポリシー（優先度順）

1. **レイ遮断カーテン**（最優先）

* 現在位置 `p` から `DIRS` それぞれについて
  `u = first_unrevealed_empty_on_ray(p, dir)` を求め，存在すれば候補に追加
  → これが\*\*次ターンの「最初の木」\*\*になり、露見範囲の伸びを止める

2. **回廊外縁の補強**（採用した静的戦略に応じて）

* 蛇行/渦巻/多段柵：回廊の**横抜け**になりえる**曲がり角の外側**に 1〜2 本のピンを打つ
* 玉ねぎ：**次に通過する扉の対角**に短い幕を追加（直進視界の遮断）

3. **ゲート先の直進潰し**

* 多段柵/クシ：ゲートを抜けた直線方向 `dir` の**2〜3 マス先**に**幕**（`first_unrevealed_empty_on_ray` を応用）

4. **s–t 安全性を常時確認**

* 候補を**距離の近いものから順**に試し、`safe_to_place` が `True` のみ採用
* 安全でなければスキップ（まとめてやらない）

### 4.2 動的 API（インタフェース）

`planner.dynamic_candidates(p_i, p_j, newly_revealed)` は
**優先順に重複なし**の候補配列を返す（上限 `budget_per_turn` を受け取ってトリミングしてもよい）

### 4.3 戦略別の動的追加テンプレ

* **蛇行回廊**：

  * `curtain_on_rays(p)` を先に
  * 次に、`p` のいる回廊 segment の**外側**（左右）へ「覗き止め柱」を 1 マスずつ
* **玉ねぎ**：

  * 現在いるリング `r` を推定（`chebyshev(p,t)`）。**次リングの扉**の**向こう側**に**先置き**（レイ遮断）
* **多段ゲート柵**：

  * 直近の柵 `row=r` の**ゲート列 g(r)** を抜ける直前に、**斜め前**と**真横**へ 1 マスずつ
* **渦巻**：

  * 曲がり角に到達する2〜3手前で、角の**外側**と**角先の直線**に 1 マス幕
* **クシ**：

  * 歯に入りそうなら**歯の奥2マス**にカーテン（目的地が歯先に固定されやすくなる）
* **エアロック**：

  * 小部屋が**露見した直後**に、**次室の反対扉**を即座に閉じる（未確認なら置ける）
* **ピラー格子**：

  * `curtain_on_rays` が主。必要に応じて**s–t回廊側**の**柱密度**を局所的に上げる
* **花の影**：

  * t の各方位で**最初に見える位置**が常に**梁**になるよう、**更新**（冒険者が回り込むにつれ梁の位置を入替）

---

## 5. 安全化・フィルタリング

### 5.1 候補フィルタ

`filter_unrevealed_empty(C)`：

* `in_bounds` && `not revealed[i][j]` && `B[i][j]=='.'`

### 5.2 逐次安全チェック

`take_until_safe(C_sorted)`：

* 空の `ans`
* for `cell in C_sorted`:

  * if `safe_to_place({cell})`: `ans.push(cell)` and **一時反映**（`B[cell]='T'`）
    → 後続のチェックは**累積反映**した `B` で行う（安全側に単調）
* return `ans`

> **注意**：複数をまとめて置くと s–t を切る場合があるため、**逐次**が原則。

---

## 6. 冒険者の行動予測（任意・強化）

* **暫定地図**の最短距離に従い 1 手だけ前進するため、
  `predict_next_step(p, d, revealed)` を実装すると「次に伸びるレイ」や「曲がり角」を**前手で抑えやすい**
* 目的地 $d$ は非公開だが、

  * **花が露見済み**なら `d=t` で確定
  * 未露見時は「未確認到達可能集合 $U$」から一様。
    → **格子/幕**で $U$ の**形を細長く**作ると遠目が選ばれやすい

---

## 7. チューニングとパラメータ

* `budget_per_turn`：0〜50 目安（環境で調整）
* **蛇行の間隔**／**柵の段間**：3〜4 マスでスタート、障害密度で可変
* **玉ねぎの層数**：t から盤外までの `min(幅/2)` 層。序盤は外側2〜3層を優先
* **ピラー周期**：2（強い）〜3（コスパ良）

---

## 8. エッジケースと対処

* **候補が未確認でない**：スキップ（露見後はもう置けない）
* **置き先が既に `'T'`**：スキップ
* **safe\_to\_place が False**：スキップ（必ず別候補を用意）
* **`U` が空（理論上 WA）**：
  これは**我々の置き過ぎ**が原因になり得る。
  → 動的では「**レイ遮断だけ**」「回廊外縁**1層だけ**」に留めるなど慎重に

---

## 9. 参考擬似コード（骨格）

```python
class PlannerBase:
    def __init__(self, N, s, t, B, revealed):
        self.N, self.s, self.t = N, s, t
        self.B = B
        self.rev = revealed

    # --- 静的 ---
    def static_candidates(self) -> list[tuple[int,int]]:
        raise NotImplementedError

    # --- 動的 ---
    def dynamic_candidates(self, p_i, p_j, newly) -> list[tuple[int,int]]:
        cand = []
        # 1) レイ遮断
        for dir in DIRS:
            u = first_unrevealed_empty_on_ray((p_i,p_j), dir)
            if u: cand.append(u)
        # 2) 戦略固有の補強
        cand += self.strategy_specific_dynamic((p_i,p_j), newly)
        # 重複除去・順序調整
        cand = dedup_stable(cand)
        return cand

    def strategy_specific_dynamic(self, p, newly): return []

def main():
    # 入力
    N, ti, tj = read()
    B = [list(input().strip()) for _ in range(N)]
    s = (0, N//2); t = (ti, tj)
    revealed = [[False]*N for _ in range(N)]
    revealed[s[0]][s[1]] = True

    # 戦略選択（例：多段ゲート）
    planner = MultiFencePlanner(N, s, t, B, revealed)

    # --- 静的配置 ---
    C0 = planner.static_candidates()
    C0 = filter_unrevealed_empty(C0)
    C0 = take_until_safe(sorted_by_priority(C0))  # 近傍->遠方 など
    place_and_output(C0)  # B を更新＋flush

    # --- ループ ---
    while True:
        pi, pj = read()
        n, *xy = read_line()
        newly = [(xy[2*k], xy[2*k+1]) for k in range(n)]
        for (x,y) in newly: revealed[x][y] = True
        if (pi,pj) == t: break

        C = planner.dynamic_candidates(pi, pj, newly)
        C = filter_unrevealed_empty(C)
        C = take_until_safe(limit(C, budget_per_turn))
        place_and_output(C)
```

> **注**：`place_and_output` は `B` を即時反映（`'.' -> 'T'`）しておくこと。次ターンの安全判定や候補生成で最新状態を使える。

---

## 10. 戦略別クラス最小仕様（要点）

### 10.1 `SnakePlanner`

* `static_candidates`：`P0` 以外の空きを蛇行順に `C` へ。ただし `P0` の**左右1列**は除外
* `strategy_specific_dynamic`：回廊の**外側**へピン，曲がり角の**外**に1マス

### 10.2 `OnionPlanner`

* `static_candidates`：リング外周 − 扉
  扉は `bfs_dist_from_s` が**減る/増える**方向を回転
* 動的：次リング扉の**向こう**に先置き，直線視界を常に**扉で止める**

### 10.3 `MultiFencePlanner`

* `static_candidates`：等間隔の柵（行 or 列）− ゲート（交互）
* 動的：ゲート通過直前の**斜め前**と**直進 2〜3 マス先**に幕

### 10.4 `SpiralPlanner`

* `static_candidates`：スパイラル回廊以外を `C`。既存木で切れたら `P0` で橋掛け
* 動的：曲がり角の**外側**＋直進先に幕

### 10.5 `CombPlanner`

* `static_candidates`：幹= `P0`，片側の歯以外を `C`（歯口1マスは除外）
* 動的：歯の**奥側**2 マスに先置き → 再抽選を誘う

### 10.6 `AirlockPlanner`

* `static_candidates`：2重柵を連鎖，小部屋**扉**は除外
* 動的：小部屋露見ごとに**次扉の向こう**を即閉

### 10.7 `LatticePlanner`

* `static_candidates`：格子規則（周期2〜3），s–t 回廊帯は除外
* 動的：`curtain_on_rays` 主体。必要に応じ回廊側密度アップ

### 10.8 `ShadePlanner`

* `static_candidates`：t 周囲の遮光梁＋外側は別プラン（蛇行/柵等）を合成
* 動的：冒険者の位置に応じて\*\*“最初に当たる梁”**の位置を**更新\*\*

---

## 11. 実装チェックリスト

* [ ] 出力後に **必ず flush**
* [ ] **未確認**かつ `'.'` にしか置かない
* [ ] **逐次**安全チェック（累積反映で単調性を担保）
* [ ] s–t 連結の**安全化パス**を静的で実施
* [ ] レイ遮断は**毎ターン**試みる
* [ ] 置き過ぎ防止：`budget_per_turn` を設ける
* [ ] 優先順：**レイ遮断 > 回廊補強 > 直進潰し**

---

## 12. 開発・検証メモ

* **性能**：$N\le 40$，BFS は $O(N^2)$。逐次判定でも余裕。
* **ロバスト性**：静的候補は**安全化パス**が命。どの盤でも s–t は通る。
* **交換性**：`PlannerBase` を継承して差し替えれば、戦略比較が容易。

---

この仕様の通りに骨格を実装し、各 `Planner` の `static_candidates` / `strategy_specific_dynamic` を埋めれば、**そのまま提出可能**な解になります。あとは `budget_per_turn` や格子周期、柵間隔などのパラメータを変えて各構築法を比較してみてください。
